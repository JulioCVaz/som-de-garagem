"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var strtok3 = require("strtok3");
var path = require("path");
var fileType = require("file-type");
var MimeType = require("media-typer");
var es6_promise_1 = require("es6-promise");
var _debug = require("debug");
var MetadataCollector_1 = require("./common/MetadataCollector");
var debug = _debug("music-metadata:parser:factory");
var ParserFactory = /** @class */ (function () {
    function ParserFactory() {
        // ToDo: expose warnings to API
        this.warning = [];
    }
    /**
     * Extract metadata from the given audio file
     * @param filePath File path of the audio file to parse
     * @param opts
     *   .fileSize=true  Return filesize
     *   .native=true    Will return original header in result
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseFile = function (filePath, opts) {
        if (opts === void 0) { opts = {}; }
        return strtok3.fromFile(filePath).then(function (fileTokenizer) {
            var parserName = ParserFactory.getParserIdForExtension(filePath);
            if (parserName) {
                return ParserFactory.loadParser(parserName, opts).then(function (parser) {
                    var metadata = new MetadataCollector_1.MetadataCollector(opts);
                    return parser.init(metadata, fileTokenizer, opts).parse().then(function () {
                        return fileTokenizer.close().then(function () {
                            return metadata.toCommonMetadata();
                        });
                    }).catch(function (err) {
                        return fileTokenizer.close().then(function () {
                            throw err;
                        });
                    });
                });
            }
            else {
                throw new Error('No parser found for extension: ' + path.extname(filePath));
            }
        });
    };
    /**
     * Parse metadata from stream
     * @param stream Node stream
     * @param mimeType The mime-type, e.g. "audio/mpeg", extension e.g. ".mp3" or filename. This is used to redirect to the correct parser.
     * @param opts Parsing options
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parseStream = function (stream, mimeType, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        return strtok3.fromStream(stream).then(function (tokenizer) {
            if (!tokenizer.fileSize && opts.fileSize) {
                tokenizer.fileSize = opts.fileSize;
            }
            return _this.parse(tokenizer, mimeType, opts);
        });
    };
    /**
     *  Parse metadata from tokenizer
     * @param {ITokenizer} tokenizer
     * @param {string} contentType
     * @param {IOptions} opts
     * @returns {Promise<INativeAudioMetadata>}
     */
    ParserFactory.parse = function (tokenizer, contentType, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        // Resolve parser based on MIME-type or file extension
        var parserId = ParserFactory.getParserIdForMimeType(contentType) || ParserFactory.getParserIdForExtension(contentType);
        if (!parserId) {
            // No MIME-type mapping found
            debug("No parser found for MIME-type / extension:" + contentType);
            var buf_1 = Buffer.alloc(4100);
            return tokenizer.peekBuffer(buf_1).then(function () {
                var guessedType = fileType(buf_1);
                if (!guessedType)
                    throw new Error("Failed to guess MIME-type");
                parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);
                if (!parserId)
                    throw new Error("Guessed MIME-type not supported: " + guessedType.mime);
                return _this._parse(tokenizer, parserId, opts);
            });
        }
        // Parser found, execute parser
        return this._parse(tokenizer, parserId, opts);
    };
    ParserFactory._parse = function (tokenizer, parserId, opts) {
        if (opts === void 0) { opts = {}; }
        // Parser found, execute parser
        return ParserFactory.loadParser(parserId, opts).then(function (parser) {
            var metadata = new MetadataCollector_1.MetadataCollector(opts);
            return parser.init(metadata, tokenizer, opts).parse().then(function () {
                return metadata.toCommonMetadata();
            });
        });
    };
    /**
     * @param filePath Path, filename or extension to audio file
     * @return Parser sub-module name
     */
    ParserFactory.getParserIdForExtension = function (filePath) {
        if (!filePath)
            return;
        var extension = path.extname(filePath).toLocaleLowerCase() || filePath;
        switch (extension) {
            case ".mp2":
            case ".mp3":
            case ".m2a":
                return 'mpeg';
            case ".ape":
                return 'apev2';
            case ".aac":
            case ".mp4":
            case ".m4a":
            case ".m4b":
            case ".m4pa":
            case ".m4v":
            case ".m4r":
            case ".3gp":
                return 'mp4';
            case ".wma":
            case ".wmv":
            case ".asf":
                return 'asf';
            case ".flac":
                return 'flac';
            case ".ogg":
            case ".ogv":
            case ".oga":
            case ".ogm":
            case ".ogx":
            case ".opus": // recommended filename extension for Ogg Opus
            case ".spx": // recommended filename extension for Ogg Speex
                return 'ogg';
            case ".aif":
            case ".aiff":
            case ".aifc":
                return 'aiff';
            case ".wav":
                return 'riff';
            case ".wv":
            case ".wvp":
                return 'wavpack';
        }
    };
    /**
     * @param {string} mimeType MIME-Type, extension, path or filename
     * @returns {string} Parser sub-module name
     */
    ParserFactory.getParserIdForMimeType = function (mimeType) {
        var mime;
        try {
            mime = MimeType.parse(mimeType);
        }
        catch (err) {
            debug("Invalid MIME-type: " + mimeType);
            return;
        }
        var subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;
        switch (mime.type) {
            case 'audio':
                switch (subType) {
                    case 'mpeg':
                        return 'mpeg'; // ToDo: handle ID1 header as well
                    case 'flac':
                        return 'flac';
                    case 'ape':
                    case 'monkeys-audio':
                        return 'apev2';
                    case 'mp4':
                    case 'aac':
                    case 'aacp':
                    case 'm4a':
                        return 'mp4';
                    case 'ogg': // RFC 7845
                    case 'opus': // RFC 6716
                    case 'speex': // RFC 5574
                        return 'ogg';
                    case 'ms-wma':
                    case 'ms-wmv':
                    case 'ms-asf':
                        return 'asf';
                    case 'aiff':
                    case 'aif':
                    case 'aifc':
                        return 'aiff';
                    case 'vnd.wave':
                    case 'wav':
                    case 'wave':
                        return 'riff';
                    case 'wavpack':
                        return 'wavpack';
                }
                break;
            case 'video':
                switch (subType) {
                    case 'ms-asf':
                    case 'ms-wmv':
                        return 'asf';
                    case 'ogg':
                        return 'ogg';
                }
                break;
            case 'application':
                switch (subType) {
                    case 'vnd.ms-asf':
                        return 'asf';
                    case 'ogg':
                        return 'ogg';
                }
                break;
        }
    };
    ParserFactory.loadParser = function (moduleName, options) {
        debug("Lazy loading parser: " + moduleName);
        if (options.loadParser) {
            return options.loadParser(moduleName).then(function (parser) {
                if (!parser) {
                    throw new Error("options.loadParser failed to resolve module \"" + moduleName + "\".");
                }
                return parser;
            });
        }
        var module = require('./' + moduleName + '/index');
        return es6_promise_1.Promise.resolve(new module.default());
    };
    return ParserFactory;
}());
exports.ParserFactory = ParserFactory;
